#===============================================================================
#
#          FILE: .zsh_prompt
# 
#         USAGE: Sourced automatically in .zshrc
# 
#   DESCRIPTION: In my opinion which I respect very much this may be one of the 
#                best zsh prompts on the planet.
# 
#===============================================================================

autoload -U colors && colors
autoload -U promptinit
autoload -Uz vcs_info

# Make the colors easier to reference
local reset white gray green red yellow blue cyan magenta black 
reset="%{${reset_color}%}"
white="%{$fg[white]%}"
gray="%{$fg_bold[black]%}"
green="%{$fg_bold[green]%}"
red="%{$fg[red]%}"
yellow="%{$fg[yellow]%}"
cyan="%{$fg[cyan]%}"
blue="%{$fg[blue]%}"
magenta="%{$fg[magenta]%}"
black="%{$fg[black]%}"

local -A pr_com            # Associative array
local -a prompt_left_lines # Array parameters


zstyle ":pr_jrock:" mode full
zstyle ':pr_jrock:*' hooks pwd usr vcs venv jobs prompt
zstyle ':pr_jrock:*' pwd "%~"

# Set vcs_info options
zstyle ':vcs_info:*' enable git                                           # We are only concerned with git VCS, so enable it
zstyle ':vcs_info:(git*):*' get-revision true                             # Allows us to get the SHA of the current branch
zstyle ':vcs_info:(git*):*' check-for-changes true                        # We want to monitor changes to the repository's
# Format of what we will display for the git repo information.
# %s - The VCS in use (git, hg, svn, etc.).
# %i - The current revision number or identifier. (SHA we only display 10 chars)
# %c - The string from the stagedstr style if there are staged changes in the repository.
# %u - The number of unapplied patches (unapplied-string).
# %b - Information about the current branch.
# %m - A "misc" replacement. It is at the discretion of the backend to decide what this replacement expands to. 
#      It is currently used by the hg and git backends to display patch information from the mq and stgit extensions.
zstyle ':vcs_info:(git*)' formats "(%s) %10.10i %c%u %b%m" # Length of SHA to display
# Format of what we will display during a special action on the repo (Ex. Interactive rebase or merge conflict)
zstyle ':vcs_info:(git*)' actionformats "(%s|${white}%a${gray}) %10.10i %c%u %b%m"
zstyle ':vcs_info:(git*):*' stagedstr "${green}Staged ${gray}"              # Set the text to display for stated changes
zstyle ':vcs_info:(git*):*' unstagedstr "${red}Unstaged${gray}"            # Set the text to display for unstated changes
zstyle ':vcs_info:git*+set-message:*' hooks git-st git-stash git-untracked # We will use hooks to inject the stashed and untracked info

# Run all the prompt hook functions
# (stolen, wholesale, from the excellent hook system in vcs_info)
function pr_run_hooks() {
    local hook func
    local -a hooks

    zstyle -g hooks ":pr_jrock:*" hooks

    (( ${#hooks} == 0 )) && return 0

    for hook in ${hooks} ; do
        func="+pr-${hook}"
        if (( ${+functions[$func]} == 0 )); then
            continue
        fi
        true
        ${func} "$@"
        case $? in
            (0)
                ;;
            (*)
                break
                ;;
        esac
    done
}

# This is our prompt, this is a compressed example it will expand
# to the width of the console
# ┌──(~/src/dotfiles)v(dotfiles)──────(✔)─
# ├──(git) d2a3f82fe9c5 Unstaged master [origin/master ]
# └───>
function +pr-mode-full() {
    local i info_line_width return_status_width filler shim

    infoline=( ${pr_com[pwd]} ${pr_com[usr]} )
    # If we are in a virtualenv we want to display that on the info line
    [[ -n ${pr_com[venv]} ]] && infoline[1]=(
        ${infoline[1]}
        "${blue} v${gray}(${pr_com[venv]}${gray})${reset}"
    )

    # The prompt was not taking up the full width of the terminal when in a virtualenv
    # If we are in a virtualenv then we add a one character shim to the width of the filler
    shim=0
    if [[ -n ${pr_com[venv]} ]]; then
        shim+=1 # Shim the filler to take up the entire width of the prompt
    fi

    # Full-width filler; search/replace color wraps to find real text width
    info_line_width=${(S)infoline//\%\{*\%\}} # search-and-replace color escapes
    info_line_width=${#${(%)info_line_width}} # expand all escapes and count the chars
    return_status_width=3 # We will take up three spaces to display the return code (✔)

    # Set the text string that will be used to fill the width of the terminal filler
    filler="${gray}${(l:$(( $COLUMNS - $info_line_width - $return_status_width + $shim ))::─:)}${reset}"
    infoline[-1]=( ${filler} ${infoline[-1]} )

    # --------------------------
    # Assemble the prompt lines
    # --------------------------
    # Default we will always have a info line and a prompt line
    lines=(
        ${(j::)infoline}
        ${pr_com[prompt]}
    )

    # If we are in a git repo we will have three lines info, git_info, prompt
    [[ -n ${pr_com[vcs]} ]] && lines[1]=(
        ${lines[1]}
        "${gray}${pr_com[vcs]}${reset}"

    )

    # Add some connecting lines to the beginning of our prompts 
    if [[ -n ${pr_com[vcs]} ]]; then
        lines[1]="${gray}┌──${lines[1]}${gray}─${reset}"
        lines[2]="${gray}├──${lines[2]}${reset}"
        lines[3]="${gray}└──➤${lines[3]}${reset}"
    else
        lines[1]="${gray}┌──${lines[1]}${gray}─${reset}"
        lines[2]="${gray}└──➤${lines[2]}${reset}"
    fi

    # And we set the value for the prompt_left_lines
    prompt_left_lines=( ${lines[@]} )
}


# Show info collected from vcs_info
function +pr-vcs() {
    local -a v_vcs

    [[ -n ${vcs_info_msg_0_} ]] && v_vcs=(
        ${gray}
        ${vcs_info_msg_0_}
        ${reset}
    )

    pr_com[vcs]=${(j::)v_vcs}
}

# Show virtualenv information
function +pr-venv() {
    local -a v_venv

    [[ -n ${VIRTUAL_ENV} ]] && v_venv=(
        ${gray}
        $(basename ${VIRTUAL_ENV})
        ${reset}
    )

    pr_com[venv]=${(j::)v_venv}
}

# Show number of background jobs, or hide if none
function +pr-jobs() {
    local -a v_jobs
    v_jobs=( "%(1j.${gray}%j${reset}.)" )
    pr_com[jobs]=${(j::)v_jobs}
}

function +pr-prompt() {
    local -a v_pwd i_pwd
    local -a exit_status i_usr i_host exit_status

    # Add the print working directory logic
    zstyle -g i_pwd ":pr_jrock:*" pwd
    v_pwd+=( ${gray}\( )
    [[ -w $PWD ]] && v_pwd+=( ${green} ) || v_pwd+=( ${yellow} )
    v_pwd+=( ${i_pwd} )
    v_pwd+=( ${gray}\) )
    v_pwd+=( ${reset} )
    pr_com[pwd]=${(j::)v_pwd}${reset}


    # Add exit status check or x logic 
    exit_status=( ${gray}\( )
    exit_status+="%(0?.${green}✔.${red}✘)"
    exit_status+=( ${gray}\) )
    exit_status+=( ${reset} )

    pr_com[usr]=${(j::)exit_status}
}

# vcs_info functions ##########################################################

# Show remote ref name and number of commits ahead-of or behind
function +vi-git-st() {
    local ahead behind remote
    local -a gitstatus

    # Are we on a remote-tracking branch?
    remote=${$(git rev-parse --verify ${hook_com[branch]}@{upstream} \
        --symbolic-full-name --abbrev-ref 2>/dev/null)}

    if [[ -n ${remote} ]] ; then
        ahead=$(git rev-list ${hook_com[branch]}@{upstream}..HEAD 2>/dev/null | wc -l | sed -e 's/^[ \t]*//')
        (( $ahead )) && gitstatus+=( "${green}+${ahead}${gray}" )

        behind=$(git rev-list HEAD..${hook_com[branch]}@{upstream} 2>/dev/null | wc -l | sed -e 's/^[ \t]*//')
        (( $behind )) && gitstatus+=( "${red}-${behind}${gray}" )

        user_data[gitstatus]=${gitstatus}
        hook_com[branch]="${hook_com[branch]} [${remote} ${(j:/:)gitstatus}]"
    fi
}

# Show the above/behind upstream counts more tersely for the compact display
function +vi-git-st-compact() {
    [[ -n ${user_data[gitstatus]} ]] \
        && hook_com[misc]="@{u}${(j:/:)user_data[gitstatus]}"
}

# Show count of stashed changes
function +vi-git-stash() {
    local -a stashes

    if [[ -s ${hook_com[base]}/.git/refs/stash ]] ; then
        stashes=$(git stash list 2>/dev/null | wc -l | sed -e 's/^[ \t]*//')
        hook_com[misc]+=" (${stashes} stashed)"
    fi
}

# Indicate if there are any untracked files present
function +vi-git-untracked() {
    local untracked

    #check if there's at least 1 untracked file
    untracked=${$(git ls-files --exclude-standard --others | head -n 1)}

    if [[ -n ${untracked} ]] ; then
        hook_com[unstaged]="${hook_com[unstaged]}${yellow} Untracked${gray}"
    fi
}

# --------------------------
# Finally we execute the above prompt functions
# --------------------------

# To be added to the precmd_* array so it is executed before each prompt
function precmd_prompt {
    local func

    # Clear out old values
    pr_com=()
    prompt_left_lines=()

    # Collect needed data
    vcs_info
    pr_run_hooks

    # Use the above data and build the prompt arrays
    func="+pr-mode-full"
    ${func} "$@"

    # Set the prompts
    PROMPT="${(F)prompt_left_lines} "
}

# --------------------------
# Right prompt which displays the vim mode
# Pulling this out for now since it is killing 
# rows above it for some odd reason. 
# --------------------------
## vim_ins_mode=""
## vim_cmd_mode="${red}[CMD]${reset}"
## vim_mode=$vim_ins_mode
## 
## function zle-keymap-select {
##     vim_mode="${${KEYMAP/vicmd/${vim_cmd_mode}}/(main|viins)/${vim_ins_mode}}"
##     zle reset-prompt
## }
## zle -N zle-keymap-select
## 
## function zle-line-finish {
##     vim_mode=$vim_ins_mode
## }
## zle -N zle-line-finish
## 
## RPROMPT='${vim_mode}'
